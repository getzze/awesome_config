local awful     = require("awful")
local naughty   = require("naughty")
local beautiful = require("beautiful")
local wibox     = require('wibox')
local pairs     = pairs
local layout    = require('wibox.layout')
local lgi = require("lgi")
local cairo = lgi.cairo
local Pango = lgi.Pango
local PangoCairo = lgi.PangoCairo
local text_box  = require('blingbling.text_box')
--local text_box  = require('wibox.widget.textbox')

local capi      = {
   mouse = mouse,
   screen = screen,
   keygrabber = keygrabber,
   client = client
}

-- BUG: when settings are taken from `beautiful` defaults, the default them is used
-- because the module is loaded before the beautiful theme is changed.
-- Workaround: the default commands is not a table, but is generated by a function
local system = {}
system.settings = {
    fg_normal = "#232323",  --light black
    bg_normal = "#999999",  --light white
    fg_focus = "#ffffff",   --white
    bg_focus = "#b9214f",    --red
    border_color = "#b9214f",  --red
    border_width = 3,
    height = 50,
    width  = 100,
    font = "Sans 48"
}

local function get_styles(styles)
	local res = {
		fg_normal = beautiful.bg_normal or styles.fg_normal or system.settings.fg_normal or "#232323",  --light black
		bg_normal = beautiful.fg_normal or styles.bg_normal or system.settings.bg_normal or "#999999",  --light white
		fg_focus = beautiful.fg_focus or styles.fg_focus or system.settings.fg_focus or "#ffffff",   --white
		bg_focus = beautiful.bg_focus or styles.bg_focus or system.settings.bg_focus or "#b9214f",    --red
		border_color = beautiful.bg_focus or styles.border_color or system.settings.border_color or "#b9214f",  --red
		border_width = styles.border_width or system.settings.border_width or 3,
		height = styles.height or system.settings.height or 50,
		width  = styles.width or system.settings.width or 100,
		font = styles.font or system.settings.font or "Sans 48"
	}
		
	return res
end

-- List command names, function, (optional) icon
local function default_commands(DEBUG)
    local DEBUG = DEBUG or false
    local comm = {}
    if not DEBUG then
        comm = {
            {"Shutdown"    , 'systemctl poweroff'         , beautiful.menu_shutdown          },
            {"Reboot"      , 'systemctl reboot'           , beautiful.menu_reboot            },
            {"Lock"        , 'systemctl lock'             , beautiful.menu_lock              },
            {"Suspend"     , 'systemctl suspend'          , nil                              },
            {"Logout"      , awesome.quit                 , beautiful.menu_logout            }
        }
    else
        local zen_cmd = 'zenity --width=100 --height=250 --list --text="Select logout action" --title="Logout"  --column "Actions"'
        comm = {
            {"Shutdown", zen_cmd .. ' Shutdown' , beautiful.menu_shutdown},
            {"Reboot"  , zen_cmd .. ' Reboot'   , beautiful.menu_reboot},
            {"Lock"    , zen_cmd .. ' Lock', beautiful.menu_lock},
            {"Suspend" , zen_cmd .. ' Suspend'  , nil},
            {"Logout"  , function() naughty.notify({ title = "Logout", text = "Logout" }) end , beautiful.menu_logout}
        }
    end
    return comm
end
system.commands = default_commands()

function deepcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepcopy(orig_key)] = deepcopy(orig_value)
        end
        setmetatable(copy, deepcopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

function system.logout_dialog_zenity ()
    local commands = system.commands
    --Create zenity list
    local cmd = 'zenity --width=100 --height=250 --list --text="Select logout action" --title="Logout"  --column "Actions"'

    for _, c in pairs(commands) do
        cmd = cmd .. ' ' .. c[1]
    end

    -- BUG : freeze awesome
    --Get zenity answer
    --local dialog = assert(io.popen(cmd))
    --if dialog then
        --local key = dialog:read('*all')
        --for _, c in pairs(commands) do
            --if key == c[1] then
                ---- Try to run the command in lua
                --local status, err = pcall(c[2])
                ---- If not, try in shell
                --if not status then
                    --awful.util.spawn_with_shell(c[2])
                --end
                --break
            --end
        --end
        --dialog:close()
    --end
end

local function launch_command(cmd)
    -- Try to run the command in lua
    if type(cmd) == 'string' then
        --awful.util.spawn(cmd)
        awful.util.spawn_with_shell(cmd)
    else
        pcall(cmd)
    end
end

local function create_menu ()
    local settings = get_styles()
    local c = default_commands()
    -- Add `cancel` option
    table.insert(c, {"--------", nil})
    table.insert(c, {"cancel", function () end})

    -- Get the max height and width of the options textbox
    local h_fit = 0      -- arbitrary height for fitting
    local w_fit = 10000  -- arbitrary width for fitting. Should work with 0, but it is not. So put a high number
    local max_height = 0
    local max_width = 0
    local w,h = 0
    local label = wibox.widget.textbox()
    label:set_font(settings.font)
    for i,k in ipairs(c) do
        label:set_text(k[1])
        w,h = label:fit(w_fit,h_fit)
        max_width  = max_width  > w and max_width  or w
        max_height = max_height > h and max_height or h
    end
    
    -- Set the height and width to the max values
    settings.height = max_height + 5
    settings.width = max_width + max_height + 10  -- add max_height because of the icon space
    local menu = awful.menu.new({ items = c, theme=settings})

    return menu
end
--system.create_menu = create_menu

function system.logout_dialog_menu ()
    local menu = create_menu()

    local screen_index = capi.mouse.screen
    local screen_geometry = capi.screen[screen_index].workarea
    local coords = {}
    
    local dialog_height = menu.wibox.height
    local dialog_width  = menu.wibox.width
    coords.x = screen_geometry.x + (screen_geometry.width  -  dialog_width)/2.
    coords.y = screen_geometry.y + (screen_geometry.height - dialog_height)/2.

    menu:show({coords=coords})
end

local function apply_style(widget, style)
	for k,v in pairs(style) do
		if widget['set_'..k] ~= nil and type(widget['set_'..k]) == "function" then
			widget['set_' ..k](widget, v)
		end
	end
end

local function show_wibox(box)
    local current_screen = capi.mouse.screen
    local screen_geometry = capi.screen[current_screen].workarea
    local x,y =0
    
    x = screen_geometry.x + (screen_geometry.width  -  box.width)/2.
    y = screen_geometry.y + (screen_geometry.height - box.height)/2.
    
    box:geometry({--width = wibox.width, 
                    --height = wibox.height,
                    x = x,
                    y = y
    })
    box.visible = true
end

local function hide_wibox(box)
    box.visible=false
end


function system.logout_dialog_wibox ()
	local ml = 2 
	local mr = 2
	local mt = 2
	local mb = 2

    local max_height = 0
    local max_width = 0

    local settings = get_styles()
	local dialog = {}
    dialog.widget = {}

    local c = default_commands()
    -- Add `cancel` option
    table.insert(c, {"--------", nil})
    table.insert(c, {"cancel", function() hide_wibox(dialog.widget) end})

    local style = { width=100, height=10, h_margin=2, v_margin=2, 
                    background_color=beautiful.bg_normal, background_text_border=beautiful.fg_normal, 
                    text_background_color=beautiful.bg_normal, rounded_size=0, 
                    text_color=beautiful.fg_normal, font_size=50, font="sans"}
    local unfocus_style = {background_color=beautiful.bg_normal, text_background_color=beautiful.bg_normal, text_color=beautiful.fg_normal}
    local focus_style   = {background_color=beautiful.bg_focus, text_background_color=beautiful.bg_focus, text_color=beautiful.fg_focus}

    -- Create dialog options
    dialog.entries = {}
    for i =1,#c do
        dialog.entries[i] = {}
        dialog.entries[i].widget = text_box(style)
        dialog.entries[i].widget:set_text(c[i][1])
        dialog.entries[i].margin = layout.margin(dialog.entries[i].widget, ml,mr,mt,mb)

        -- Attach mouse action
        if i ~= (#c-1) then
            dialog.entries[i].widget:buttons(awful.util.table.join(
                    awful.button({ },  1, function() launch_command(c[i][2]) end, function() hide_wibox(dialog.widget) end ) ))
            dialog.entries[i].widget:connect_signal("mouse::enter", function() apply_style(dialog.entries[i].widget, focus_style) end)
            dialog.entries[i].widget:connect_signal("mouse::leave", function() apply_style(dialog.entries[i].widget, unfocus_style) end)
        end

        -- Calculate max size
        w,h = dialog.entries[i].margin:fit(0,0)
        max_width = max_width > w and max_width or w
        max_height = max_height > h and max_height or h
    end


    -- Resize dialog
    dialog.column = layout.fixed.vertical()
    for i =1,#c do
        -- Make identical cases
        dialog.entries[i].widget:set_width(max_width)
        dialog.entries[i].widget:set_height(max_height)
        --dialog.entries[i].widget:set_align("center")
        --dialog.entries[i].widget:set_valign("center")
        dialog.column:add(dialog.entries[i].margin)
    end
    
    local dialog_height = #c * (max_height + 4)   -- include margin
    local dialog_width  = max_width
    --local dialog_height = settings.height
    --local dialog_width  = settings.width
    dialog.widget = wibox({ontop = true,
                        height = dialog_height,
                        width  = dialog_width   })
    dialog.widget:set_widget(dialog.column)
    dialog.widget:buttons(awful.util.table.join(
                awful.button({ },  3, function() hide_wibox(dialog.widget) end ) ))

    show_wibox(dialog.widget)
end


return system
